/**
 * Define styles for a set of per-color sub-classes of an element.
 *
 * The mixin content block will be applied to a set of classes determined by
 * the $prefix and $sets arguments, and in the content block, the variable
 * $color is assigned to the hex value for the color for each class.
 *
 * @param string $prefix Each generated class will be prefixed with this
 *                       string, followed by a hyphen.
 * @param list   $sets   Each member of this list should be a string that
 *                       corresponds to a key in the global $color-sets map
 *                       (see _variables.scss).
 *
 * Boring example:
 *
 * .thing {
 *   @include colorize( pfx, rainbow social ) {
 *     color: $color;
 *   }
 * }
 *
 * ...becomes:
 *
 * // from the 'rainbow' set:
 * .thing.pfx-gold { color: #ff8b18; }
 * .thing.pfx-teal { color: #3bdf9a; }
 * .thing.pfx-lime { color: #aacc00; }
 * // ...etc., and from the 'social' set:
 * .thing.pfx-facebook { color: #3b5998; }
 * .thing.pfx-twitter { color: #4099ff; }
 */

// Initialize the global $color variable, which this mixin will use as it
// iterates. $color needs to be global in order for the mixin content block to
// be able to access it.
$color: null !global;

@mixin colorize( $prefix: color, $sets: $color-set-default ) {

	// Save current value of the $color global, just in case there is one.
	$global-color: $color;

	// Initialize a map where we'll temporarily store the desired color sets.
	$merged-sets: ();

	// Merge all the desired color sets into $merged-sets.
	@each $set-name in $sets {
		$merged-sets: map-merge( $merged-sets, map-get( $color-sets, $set-name ) );
	}

	// Iterate over each color in $merged-sets.
	@each $theme-name, $color-value in $merged-sets {

		$color: $color-value !global;

		// Apply the styles in the mixin content block for this color class.
		&.#{$prefix}-#{$theme-name} {
			@content;
		}
	}

	// Restore previous value of $color.
	$color: $global-color !global;
}

/**
 * Define padding + bottom margins for a hero element involving a floated image that should overlap with the bottom edge of the container.
 */
@mixin hero-float-margins( $overlap-bottom, $margin-bottom: rem(30), $breakpoint: $desktop ) { // $padding: rem(60) ) {

	@include breakpoint( $breakpoint ) {
		padding: rem(60) 0;
		margin: 0 0 $overlap-bottom + $margin-bottom;

		.hero-image {
			margin-bottom: - ( $overlap-bottom + rem(60) );
		}
	}
}

/**
 * Use an inline SVG image as a background.
 */
@mixin svg-bg( $name ) {
	@extend .icon-#{$name};
	background-repeat: no-repeat;
	background-position: center top;
	width: auto;
	height: auto;
}
